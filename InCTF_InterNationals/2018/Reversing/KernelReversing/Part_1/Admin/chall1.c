#include <sys/cdefs.h>

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/md5.h>
#include <sys/sha1.h>
#include <sys/lua.h>
#include <sys/module.h>
#include <lua.h>
#include <lauxlib.h>

#include <sys/kmem.h>
#include <uvm/uvm.h> 

dev_type_open(chall1_open);
dev_type_close(chall1_close);
dev_type_read(chall1_read);
dev_type_write(chall1_write);

#define YOULOSE "Why don't you try again?"
#define BUFFER_LEN 100

static int check_check(char *);
void get_flag_ready(void);
void md5hash(void);
void sha1hash(void);

static struct cdevsw chall1_cdevsw = {
	.d_open = chall1_open,
	.d_close = chall1_close,
	.d_read = chall1_read,
	.d_write = chall1_write,
	.d_ioctl = noioctl,
	.d_stop = nostop,
	.d_tty = notty,
	.d_poll = nopoll,
	.d_mmap = nommap,
	.d_kqfilter = nokqfilter,
	.d_discard = nodiscard,
	.d_flag = D_OTHER
};


struct chall1_softc {
	int		 refcnt;
	unsigned	 last;
	klua_State	*kL;
	char *buffer;
	char *final_flag;
	int buf_len;
	char md5string[33];
	char sha1string[41];
};

unsigned char __luac_out[] = {
  0x1b, 0x4c, 0x75, 0x61, 0x53, 0x00, 0x19, 0x93, 0x0d, 0x0a, 0x1a, 0x0a,
  0x04, 0x08, 0x04, 0x08, 0x08, 0x78, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x72, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x15, 0x40,
  0x2f, 0x68, 0x6f, 0x6d, 0x65, 0x2f, 0x6b, 0x61, 0x6d, 0x69, 0x6c, 0x2f,
  0x6e, 0x65, 0x77, 0x2e, 0x6c, 0x75, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0f, 0x00, 0x00, 0x00, 0x2a, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x00, 0x80, 0x2a, 0x40, 0x00, 0x00, 0x08, 0x00,
  0x80, 0x80, 0x2a, 0x80, 0x00, 0x00, 0x08, 0x00, 0x00, 0x81, 0x2a, 0xc0,
  0x00, 0x00, 0x08, 0x00, 0x80, 0x81, 0x2a, 0x00, 0x01, 0x00, 0x08, 0x00,
  0x00, 0x82, 0x2a, 0x40, 0x01, 0x00, 0x08, 0x00, 0x80, 0x82, 0x2a, 0x80,
  0x01, 0x00, 0x08, 0x00, 0x00, 0x83, 0x24, 0x00, 0x80, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x04, 0x11, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c,
  0x61, 0x67, 0x5f, 0x63, 0x68, 0x61, 0x72, 0x62, 0x04, 0x11, 0x63, 0x68,
  0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x68, 0x61,
  0x72, 0x69, 0x04, 0x11, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c,
  0x61, 0x67, 0x5f, 0x63, 0x68, 0x61, 0x72, 0x30, 0x04, 0x11, 0x63, 0x68,
  0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x68, 0x61,
  0x72, 0x73, 0x04, 0x11, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c,
  0x61, 0x67, 0x5f, 0x63, 0x68, 0x61, 0x72, 0x43, 0x04, 0x11, 0x63, 0x68,
  0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x5f, 0x63, 0x68, 0x61,
  0x72, 0x54, 0x04, 0x11, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x5f, 0x66, 0x6c,
  0x61, 0x67, 0x5f, 0x63, 0x68, 0x61, 0x72, 0x46, 0x01, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x07, 0x00, 0x00, 0x00, 0x1d, 0x00,
  0x40, 0x00, 0x1c, 0x40, 0x00, 0x80, 0x41, 0x40, 0x00, 0x00, 0x64, 0x00,
  0x00, 0x01, 0x41, 0x80, 0x00, 0x00, 0x64, 0x00, 0x00, 0x01, 0x24, 0x00,
  0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13, 0x57, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x07,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x07, 0x00, 0x00, 0x00, 0x1d,
  0x00, 0x40, 0x00, 0x1c, 0x40, 0x00, 0x80, 0x41, 0x40, 0x00, 0x00, 0x64,
  0x00, 0x00, 0x01, 0x41, 0x80, 0x00, 0x00, 0x64, 0x00, 0x00, 0x01, 0x24,
  0x00, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13, 0x33, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x09, 0x00,
  0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x0a, 0x00,
  0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0d, 0x00,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x6e, 0x00, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00,
  0x00, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x07, 0x00, 0x00, 0x00,
  0x1d, 0x00, 0x40, 0x00, 0x1c, 0x40, 0x00, 0x80, 0x41, 0x40, 0x00, 0x00,
  0x64, 0x00, 0x00, 0x01, 0x41, 0x80, 0x00, 0x00, 0x64, 0x00, 0x00, 0x01,
  0x24, 0x00, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13, 0x6c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11,
  0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x6e, 0x00, 0x00, 0x00,
  0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00,
  0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x07, 0x00, 0x00,
  0x00, 0x1d, 0x00, 0x40, 0x00, 0x1c, 0x40, 0x00, 0x80, 0x41, 0x40, 0x00,
  0x00, 0x64, 0x00, 0x00, 0x01, 0x41, 0x80, 0x00, 0x00, 0x64, 0x00, 0x00,
  0x01, 0x24, 0x00, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13, 0x43, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x17, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
  0x18, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
  0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x6e, 0x00, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d,
  0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x07, 0x00,
  0x00, 0x00, 0x1d, 0x00, 0x40, 0x00, 0x1c, 0x40, 0x00, 0x80, 0x41, 0x40,
  0x00, 0x00, 0x64, 0x00, 0x00, 0x01, 0x41, 0x80, 0x00, 0x00, 0x64, 0x00,
  0x00, 0x01, 0x24, 0x00, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
  0x00, 0x1e, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00,
  0x00, 0x1f, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00,
  0x00, 0x22, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x6e, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x24, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x07,
  0x00, 0x00, 0x00, 0x1d, 0x00, 0x40, 0x00, 0x1c, 0x40, 0x00, 0x80, 0x41,
  0x40, 0x00, 0x00, 0x64, 0x00, 0x00, 0x01, 0x41, 0x80, 0x00, 0x00, 0x64,
  0x00, 0x00, 0x01, 0x24, 0x00, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x13,
  0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
  0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x26, 0x00,
  0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x28, 0x00,
  0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x6e,
  0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x2b, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02,
  0x07, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x40, 0x00, 0x1c, 0x40, 0x00, 0x80,
  0x41, 0x40, 0x00, 0x00, 0x64, 0x00, 0x00, 0x01, 0x41, 0x80, 0x00, 0x00,
  0x64, 0x00, 0x00, 0x01, 0x24, 0x00, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x13, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
  0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x2d,
  0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x2f,
  0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
  0x6e, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x0f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x0d, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
  0x00, 0x0f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00,
  0x00, 0x22, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00,
  0x00, 0x24, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00,
  0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x05, 0x5f, 0x45, 0x4e, 0x56
};
unsigned int __luac_out_len = 1278;

static struct chall1_softc sc;

/* Function that calls a Lua routine and returns whether a number is chall */
static int
check_chall(void)
{
	int n[8];
	int rv;
	char jumper[8] = "bi0sCTF";
	char *func_name =  kmem_zalloc(0x50,KM_SLEEP);
	if(*sc.buffer == 0)
	{
		printf("Input is null\n");
		return -1;
	}
	if(strlen(sc.buffer) != 7)
	{
		printf("Input size Wrong!\n");
		return -1;
	}
	for(int i = 0; i < 8; i++)
	{
		n[i] = (int)*(sc.buffer+i);
	}
	klua_lock(sc.kL);
	for (size_t i = 0; i < 7; i++)
	{
		snprintf(func_name, strlen("check_flag_char")+1,"check_flag_char");
		strncat(func_name, jumper + i, 1); 
		lua_getglobal(sc.kL->L, func_name);

			if (!lua_isfunction(sc.kL->L, -1)) {
				lua_pop(sc.kL->L, 1);
				printf("Error 1\n");
				klua_unlock(sc.kL);
				return -1;
			}

			lua_pushnumber(sc.kL->L, n[i]);
			if (lua_pcall(sc.kL->L, 1, 1, 0) != 0) {
				lua_pop(sc.kL->L, 2);
				printf("Error 2\n");
				klua_unlock(sc.kL);
				return -1;
			}

			if (!lua_isnumber(sc.kL->L, -1)) {
				lua_pop(sc.kL->L, 1);
				printf("Error 3\n");
				klua_unlock(sc.kL);
				return -1;
			}

			rv = lua_tointeger(sc.kL->L, -1);
			lua_pop(sc.kL->L, 1);
			
		if (rv != 0) { 
			printf("You have more to learn\n");
			return -1;
		}
			
	}
	klua_unlock(sc.kL);
	return rv;
}

void md5hash(void){
	unsigned char digest[16];
	struct MD5Context context;
	MD5Init(&context);
	MD5Update(&context, sc.buffer, strlen(sc.buffer));
	MD5Final(digest, &context);
	for(int i = 0; i < 16; ++i)
    		snprintf(&sc.md5string[i*2],5, "%02x", (unsigned int)digest[i]);
}

void sha1hash(void) {
	unsigned char digest[20];
	SHA1_CTX context;
	SHA1Init(&context);
	SHA1Update(&context,sc.md5string, strlen(sc.md5string));
	SHA1Final(digest, &context);
	for(int i = 0; i < 20; ++i)
    		snprintf(&sc.sha1string[i*2],5, "%02x", (unsigned int)digest[i]);
}

void
get_flag_ready()
{
	char xor_pack[40] = {92, 11, 1, 77, 5, 25, 104, 84, 70, 109, 81, 97, 3, 108, 82, 57, 72, 103, 2, 61, 14, 12, 93, 92, 104, 94, 12, 11, 25, 81, 94, 107, 12, 5, 66, 4, 95, 76, 64, 27};
	md5hash();
	sha1hash();
	for(size_t i = 0; i < strlen(sc.sha1string); i++)
	{
		*(sc.final_flag + i) = (int)*(sc.sha1string + i) ^ (int)*(xor_pack + i);
	}
}

int
chall1_open(dev_t self __unused, int flag __unused, int mode __unused,
           struct lwp *l __unused)
{
	if (sc.refcnt > 0)
		return EBUSY;

	sc.last = 0;
	++sc.refcnt;
	sc.buf_len = BUFFER_LEN;
	sc.buffer = (char *)kmem_alloc(BUFFER_LEN, KM_SLEEP);

	sc.final_flag = (char *)uvm_km_alloc(kernel_map, BUFFER_LEN * sizeof(char),
					0,UVM_KMF_WIRED | UVM_KMF_ZERO);
	return 0;
}

int
chall1_close(dev_t self __unused, int flag __unused, int mode __unused,
            struct lwp *l __unused)
{
	--sc.refcnt;

	return 0;
}

int
chall1_read(dev_t self __unused, struct uio *uio, int flags __unused)
{
	char line[80];
	int e;
	
	int check = check_chall();
	/*
	There is a kernel panic in check chall at the strcat() function
	Have skipped this part for now.
	*/

	//int check = 0;
	if(check == 0){
		get_flag_ready();
		snprintf(line, strlen(sc.final_flag)+1 , "%s", sc.final_flag);
		if ((e = uiomove(line, strlen(sc.final_flag)+1, uio)))
			return e;
	}else{
		snprintf(line, strlen(YOULOSE)+1 , "%s", YOULOSE);
		if ((e = uiomove(line, strlen(YOULOSE), uio)))
			return e;
	}	
	return 0;
}

int
chall1_write(dev_t self, struct uio *uio, int flags)
{
    if (sc.buffer)
	kmem_free(sc.buffer, sc.buf_len);
    sc.buf_len = uio->uio_iov->iov_len;
    sc.buffer = (char *)kmem_alloc(sc.buf_len, KM_SLEEP);
    uiomove(sc.buffer, sc.buf_len, uio);
    return 0;
}

MODULE(MODULE_CLASS_MISC, chall1, "lua");

static int
chall1_modcmd(modcmd_t cmd, void *arg __unused)
{
	/* The major should be verified and changed if needed to avoid
	 * conflicts with other devices. */
	int cmajor = 210, bmajor = -1;

	switch (cmd) {
	case MODULE_CMD_INIT:
		if (devsw_attach("chall1", NULL, &bmajor, &chall1_cdevsw,
		                 &cmajor))
			return ENXIO;
		printf("Challenge module loaded\n");
		if ((sc.kL = kluaL_newstate("chall1",
		                            "NetBSD kernel RE challenge",
		                            IPL_NONE)) == NULL) {
			devsw_detach(NULL, &chall1_cdevsw);
			return ENXIO;
		}
		int err = luaL_loadbufferx(sc.kL->L,__luac_out,__luac_out_len,"inctf","bt");
		if (err != LUA_OK) {
			const char* se = lua_tostring(sc.kL->L, -1);
			printf("[error] %s\n", se);
			printf("oops! in luaL_loadbufferx err=%d\n", err);
			devsw_detach(NULL, &chall1_cdevsw);
			klua_close(sc.kL);
			return ENXIO;
		}
		err = lua_pcall(sc.kL->L, 0, 0, 0);
		if (err != LUA_OK) {
			printf("oops! in lua_pcall\n");
			const char* se = lua_tostring(sc.kL->L, -1);
			printf("[error] %s\n", se);
                        printf("oops! in lua_pcall err=%d\n", err);
                        devsw_detach(NULL, &chall1_cdevsw);
			klua_close(sc.kL);
                        return ENXIO;
		}
		return 0;
	case MODULE_CMD_FINI:
		if (sc.refcnt > 0)
			return EBUSY;

		klua_close(sc.kL);
		devsw_detach(NULL, &chall1_cdevsw);
		return 0;
	default:
		return ENOTTY;
	}
}
